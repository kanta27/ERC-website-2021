{"pageProps":{"allBlogs":[{"frontmatter":{"title":"Arduino","author":"Tejas Amritkar","hero_image":"/ERC-website-2021/static/arduino_cover.jpg","date":"2021-11-24T12:30:00.000Z"},"markdownBody":"Arduino is an **open-source electronics platform** based on easy-to-use hardware and software. Arduino boards are able to read inputs - light on a sensor, a finger on a button, or a Twitter message - and turn it into an output - activating a motor, turning on an LED, publishing something online.\n\n* Open-source Electronics prototyping platform\n* Uses a ‚Äúmicroprocessor‚Äù/‚Äùmicrocontroller‚Äù\n* Programmable in language similar to C\n* Implements many inbuilt functions\n* Multiple sensors available for use\n* Lots of support online - very popular\n\nThere are different Arduino Boards available in the market like Arduino UNO (R3), Arduino Nano, Arduino Mega (R3), etc. We will focus on **Arduino UNO R3** in this tutorial.\n\n# Programming Arduino\n\n* Arduino uses its own IDE (Integrated Development Environment) to write programs.\n* Setting up and programming Arduino : [Arduino](https://www.youtube.com/watch?v=fJWR7dBuc18 \"Arduino Setup\")\n\n# Arduino UNO\n\n## Arduino pins\n\nIf you want detailed info on any of the pins , you can visit here:  \n[robotics backend/arduino-uno-pins](https://roboticsbackend.com/arduino-uno-pins-a-complete-practical-guide/)\n\n![](/ERC-website-2021/static/arduino_image2.png)\n\n1 - USB CONNECTOR  \n2 - POWER JACK  \n3 - GROUND PINS  \n4 - 5V PINS  \n5 - 3.3V PINS  \n6 - ANALOG INPUT PINS  \n7/8 - DIGITAL PINS- out of the 14 Pins, 6 can be used for PWM (denoted by \\~)  \n9 - ANALOG REFERENCE  \n10 - RESET BUTTON  \n11 - POWER LED  \n12 - TX/RX LEDS  \n13 - ATMEGA328P  \n14 - VOLTAGE REGULATOR\n\n## Power Pins\n\n![](/ERC-website-2021/static/arduino_image1.png)\n\n* Vin is the input voltage to the board when it‚Äôs using an external power source (as opposed to 5 volts from the USB connection or other regulated power source from the power jack)\n* You can supply voltage through this pin(from external circuitry), or, if supplying voltage via the power jack, access it through this pin.\n* This is how you power the board when it‚Äôs not plugged into a USB port for power. Can accept voltages between 7-12V(But the voltage is regulated to a maximum of 5V)\n\n## LEDs\n\n* **Pin 13 LED:** The only actuator built into the board. Useful for debugging, since the LED is in-built and hence reliable in terms of connections.\n* **Power LED:** Indicates that the board is receiving power. Useful for debugging.\n* **Reset button:** Resets the ATmega microcontroller.\n* **TX and RX LEDs:** Indicate communication(send/receive) between the board and the computer. Flicker rapidly during sketch upload as well as during serial communication. Useful for debugging.\n\n## USB Port\n\n* Used for the board, and most importantly, uploading your sketches to the board.\n* Also used for communicating with the sketch (via Serial.println() etc).\n\n## Digital Pins\n\n![](/ERC-website-2021/static/arduino_image8.png)  \nDigital **Input/Output** pins(0,1 are serial in/out) are numbered from 2-13  \nHigh(5V) or Low(0V)  \nDigital reading pins ( for input V < 0.8 => low; V > 2 => high)\n\n**Arduino LED:**\n\nExample 1:  \nLet‚Äôs make the LED blink, which means that we are going to :\n\n1. Power in the LED\n2. Wait\n3. Power off the LED\n4. Wait\n5. Go back to 1\n\nSee the code here : [Example1](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#example-1)\n\n![](/ERC-website-2021/static/arduino_image3.png)\n\n**digitalWrite(Pin_no, HIGH/LOW);**  \nHIGH sets the pin to give a 5V (high) output while a low sets the pin to give a 0V output.  \nOnly to assign the value to the output pins.\n\n**digitalRead(Pin_no);**  \nGives the reading of the digital input pin as a high or a low.\n\n## PWM Pins\n\nPWM enabled pins(3,5,6,9,10,11) can also be used as Analog **Outputs** (represented by \\~)  \nanalogWrite(LED_PIN, n); **n** can take values from **0 to 255**.\n\nIn the Example1 replacing line digitalWrite(LED_PIN, HIGH); with analogWrite(LED_PIN, 102); will cause 102/255 ie. 40% of maximum voltage( 5V) across circuit.  \n(can be used to change the brightness of the LED in this example)\n\nExample 2:  \nLet‚Äôs make the LED fade in (which means the brightness will slowly increase until the max), and then fade out (brightness will slowly decrease), so we can create a nice effect with the LED.  \nSee the code here : [Example2](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#example-2)\n\n## Analog Pins\n\n![](/ERC-website-2021/static/arduino_image14.png)\n\n\\**analogRead(Pin_no);  \n\\**Reads the input from the analog pins marked as A0,A1...A5 on the arduino board. This reading is a 10 bit value (0-1023).\n\nLet's say Arduino is reading 2V.  \n2V is 40% of 5V (Vcc). In your Arduino program, you will then get the value 409 ( 40% of 1024 ). From this value, you can easily reverse the computation and get the information about the voltage that was applied.\n\n## Serial Communication\n\nSerial is used for communication between the Arduino board and a computer or other devices. All Arduino boards have at least one serial port (also known as a UART or USART). It communicates on digital pins 0 (RX) and 1 (TX) as well as with the computer via USB. Thus, if you use these functions, you cannot also use pins 0 and 1 for digital input or output.\n\n\\**Arduino Serial port and Print Commands:  \n\\**See the example here : [Example 3](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#example-3)  \nOpen the Serial monitor ( on top right corner)\n\nSerial.begin(baud_rate);  \nSets the data rate in bits per second (baud) for serial data transmission. Settable to 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600 or 115200 baud rate defined here and that selected on the serial monitor should be the same.\n\nSerial.end();  \nDisables serial communication, allowing the RX and TX pins to be used for general input and output.\n\nif(Serial);  \nIndicates if the specified Serial port is ready.\n\nSerial.available();  \nGet the number of bytes (characters) available for reading from the serial port.\n\nSerial.read();  \nReads incoming data\n\nSerial.print(j);  \nprint on the same line\n\nThere are many serial functions that have not been covered in the previous segment, but they are important for some specific uses.  \n[https://www.arduino.cc/en/reference/serial](https://www.arduino.cc/en/reference/serial \"https://www.arduino.cc/en/reference/serial\")\n\n\\**Reading data from serial monitor :  \n\\**Example 4 : Tell the Arduino how many times you want to blink LED  \nSee the code here: [Example 4](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#exmaple-4)\n\n## Interrupt Pins\n\nPurpose - Stop the continuous progress of an activity or process.  \nInterrupts triggers a function inside the Arduino code. This stops the main execution of your program. After the triggered function is done, the **main execution resumes**.\n\n**Digital Pins 2, 3** are Interrupts pins.\n\nBefore going through the example, lets introduce the **push button**. You should notice which pins are internally connected and which are not.\n\n![](/ERC-website-2021/static/arduino_image4.jpg)\n\n**Example 5:** The goal of the Example is to change the state of a LED when the the user presses a push button.\n\nPart 1 : Arduino code without interrupts  \nSee the code here : [Example5_Part1](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#part-1)\n\nPart 2 : Arduino code with Interrupts  \nSee the code here : [Example5_Part2](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#part-2)\n\n![](/ERC-website-2021/static/arduino_image6.png)\n\n**Note** : Make the interrupt function as fast as possible, because it stops the main execution of your program.\n\n**Volatile Variables :**\n\nIf you modify a variable inside an interrupt, then you should declare this variable as volatile.\n\nThe compiler does many things to optimize the code and the speed of the program. This is a good thing, but here we need to tell it to ‚Äúslow down‚Äù on optimization.\n\nFor example, if the compiler sees a variable declaration, but the variable is not used anywhere in the code (except from interrupts), it may remove that variable. With a volatile variable you‚Äôre sure that it won‚Äôt happen, the variable will be stored anyway.\n\nNote that only variables that are used inside and outside an interrupt should be declared as volatile. You don‚Äôt want to unnecessarily slow down your code.\n\nIf you want to get deeper into Interrupt pins, check this out : [arduino-interrupts](https://roboticsbackend.com/arduino-interrupts/)\n\n# Peripherals\n\nArduino supports multiple peripherals like:\n\n* Ultrasonic Sensor\n* LCD\n* Bluetooth\n* Pressure Sensor\n* Accelerometer/Gyrometer\n* RTC module\n* SD card\n* LDR sensor\n* Temperature sensor\n\n## Ultrasonic Sensor\n\n* This sensor sends out pulses from T, which bounce off from the object and R receives them.\n* When the receiver gets the U.S. pulses, it generates a high signal. We get the time difference between the pulses which is used to calculate the distance\n* The speed of sound is approximately 341 meters (1100 feet) per second in air.\n* **Distance = (Time x Speed of Sound)/2**\n\n![](/ERC-website-2021/static/arduino_image15.png)\n\nUseful Function:  \npulseIn(Pin_no, HIGH);  \nGives the time in milliseconds from the time this command is initiated until Pin_no gives a HIGH pulse.\n\n**Sample:**\n\n* Initialise variables before setup()\n* Sets the data rate of data received from the board using Serial.begin() and sets the trig pin to OUTPUT and echo pin to INPUT.\n* First three lines of loop() send out a trigger pulse on the trig pin to cause the sensor to emit an ultrasound pulse.\n* pulseIn(echo, HIGH) records the time after which the echo pin receives a HIGH pulse.\n* Data is converted into distance in cm and printed to the Serial monitor.\n\n**Exercise:**\n\nHow to measure distance using Ultrasonic sensor **HC-SR04  \n\\**[using an Ultrasonic sensor](https://create.arduino.cc/projecthub/knackminds/how-to-measure-distance-using-ultrasonic-sensor-hc-sr04-a-b9f7f8) (Error in pin mapping)  \nNote (TRIG connection of the sensor attached to digital **pin 12  \n\\**ECHO connection of the sensor attached to digital **pin 13**)\n\n## LCD\n\nWhy is the LCD used?  \nTo display certain information or data on the screen. They are useful for debugging when you cannot use a laptop or serial monitor.\n\n![](/ERC-website-2021/static/arduino_image9.png)![](/ERC-website-2021/static/arduino_image13.png)\n\n**Functions:**\n\n* lcd.begin(16,2): This declares the size of LCD\n* lcd.clear(): Clears the LCD\n* lcd.setCursor(0,0): Moves the cursor to (0,0) of the array\n* lcd.print(‚Äúhello world‚Äù): Prints whatever is in the bracket\n\n**Exercise:**\n\nWrite code to display the distance directly onto the LCD  \nFor more information visit : [Liquid_Crystal_Library](https://www.arduino.cc/en/Reference/LiquidCrystal)\n\n## Infrared Sensor\n\n![](/ERC-website-2021/static/arduino_image10.png)\n\n* I.R. sensor is used as a proximity sensor or collision sensor (not exact distance).\n* TX which emits IR light continuously.\n* So, when an object is near the sensor light is reflected into the RX which creates a voltage difference.\n* The generation of this voltage difference depends on the intensity of IR light received by the RX\n* **Note: You cannot use IR sensors outdoors or in bright lights because the IR light of the sun or from the bulb interacts with the RX. Use US sensors instead.**\n\n  ![](/ERC-website-2021/static/arduino_image16.png)\n\n\\**IR Sensor People Counter  \n\\**To make a device which counts the number of people entered, excited and present in the room using an IR sensor.\n\n![](/ERC-website-2021/static/arduino_image12.png)![](/ERC-website-2021/static/arduino_image7.png)\n\n**Example**\n\n* For an Arduino UNO we can only send one byte at a time and hence we will communicate between the two arduinos using characters ‚ÄúH‚Äù and ‚ÄúL‚Äù. (We can do this using numbers as well)\n* One Arduino will serve as a sender while the other will be a receiver. The communication will take place through the set of Serial() functions.\n\n## Bluetooth Module\n\n![](/ERC-website-2021/static/arduino_image5.jpg)\n\nHere is our Bluetooth Module with its Pinout.  \nThe Bluetooth Module will communicate with Arduino via Tx / Rx Pins (Pin1/Pin0) present on Arduino,as we used second Arduino in above communication.  \nPs:We Only Need **Vcc,Gnd,Tx,Rx** Pins For Such Communication.\n\n![](/ERC-website-2021/static/arduino_image11.png)\n\nArduino bluetooth basic tutorial: [working on bluetooth module](https://create.arduino.cc/projecthub/mayooghgirish/arduino-bluetooth-basic-tutorial-d8b737)\n\n# Arduino Communication Protocols\n\nThree Protocols for device communication :\n\n1. **UART** - Universal Asynchronous Receiver/Transmitter\n2. **SPI** - Serial Peripheral Interface\n3. **I2C** - Inter-integrated circuit\n\nDetails can be seen here : [Arduino-communication-protocols](https://www.deviceplus.com/arduino/arduino-communication-protocols-tutorial/)","slug":"arduino"},{"frontmatter":{"title":"Controls Theory","author":"Pranav Malpure","hero_image":"/ERC-website-2021/static/controls_theory_cover.jpg","date":"2021-11-25T13:50:00.000Z"},"markdownBody":"Control theory is a branch of mathematics and engineering, which defines the conditions needed for a system to maintain a controlled output in the face of input variation. In simple terms, we seek to stabilize our system through some control theory concepts when many factors can destabilize it. At the end of reading this article, you can expect to have an overview of control theory with some basic knowledge of PID control.\n\nTo understand this, first, let us know a few terms:\n\n1\\. **Input:** The set of instructions given to the system\n\n2\\. **Output:** Consists of a group of variables that describe the state of the system. Usually represented by ùë•\n\n3\\. **Control System:** The entire system, which includes a _controller_, _plant_, and _sensors_, is collectively known as a control system. The _plant_ is a part that is controlled. The _controller_ provides control commands to the plant. _Sensors_ measure the state of the system. See the flow diagram for reference:\n\n![](/ERC-website-2021/static/image9.png)\n\nTo put these terms into an application, let‚Äôs take the example of a person driving a car. (Pause here and try to identify what could be the input, output, and control system in this example.) So, in this case, the _input_ could be instructions given to the driver by his brain. The driver will be the _controller_, which controls the car using the instructions received. The vehicle will be the _plant_; sensors would be the speedometer, driver‚Äôs eyes to see the traffic, ears to listen to any horn, etc. The _output_ could be the velocity of the car, current traffic conditions on the road, etc.\n\nNow that you understand basic terms let's move on to classifying control systems.\n\nWe classify control systems on various bases, but the most prominent ones are:\n\n## 1. Based on feedback (output)\n\n* **Open-loop control system** - In this type of system, the input given to the controller is independent of the output. In the above car example, we can see that if the driver doesn‚Äôt pay heed to the current state of the system(the output) and drives it just based on some pre-learned instructions, then this system would be an open loop, as there are no changes made to the input depending on the output. As you must have noticed, this type of system is problematic as it cannot account for any uncertainties.\n* **Closed-loop control system** - Here, the input commands are based on the output received. For example, when a car stops in front, the driver‚Äôs input will change, and they will apply brakes.\n\n## 2. Based on energy expenditure\n\n* **Active** - In this type, a certain amount of energy is required to implement the control commands. For example, to accelerate the car, it will consume fuel.\n* **Passive** - This system involves minimal energy expenditure to implement the input into the system. For example, if the car goes downhill, it can be controlled by just applying the brakes.\n\nSince we now have an overview of control theory, let us bring some maths into the picture, let the input function be _u(t)_ and output function be _x(t)_.\n\nWondering what use maths is of? Read on...\n\n# Control Law\n\nVarious types of systems have different anomalies present in them. In many cases, we can express the output and correction to the input to control the system through some mathematical relation. This relation is known as a _control law_. So, a _control law_ is a mathematical law that relates output and input, along with other control command parameters or measurable properties of the state.\n\nExample:   \t\tu(t) = -K(x(t) - x0)\n\nThere are various control laws, such as _Linear Quadratic Regulator_ (the above example is an LQR), _PID control_, etc., which may be helpful in different scenarios. One such law is PID which is widely used even in industries because it is simple and works for almost every case.\n\n# Proportional-Integral-Derivative (PID)\n\nThe control law for PID is:\n\n![](/ERC-website-2021/static/image5.png)\n\nDon‚Äôt get overwhelmed with the equation! It‚Äôs pretty simple when you understand it.\n\nLet us understand what each term is:\n\n1\\. **Kp** is the proportional coefficient/weight\n\n2\\. **Kd** is the derivative coefficient/weight\n\n3\\. **Ki** is the integral coefficient/weight\n\n4\\. **Ti** is the integral time constant\n\n5\\. **Td** is the derivative time constant\n\nHere, _e(t)_ is the error between the desired and the actual state.\n\nThis law has three parts: **proportional**, **integral** and **derivative** parts; each one of them has its own importance.\n\n**Proportional(P)**\n\nIn this the input is linearly proportional to the error, which means that the error is just scaled using the constant **Kp**.\n\n**Integral(I)**\n\nThe integral of error over time is scaled with a constant **Ki**.\n\n**Derivative(D)**\n\nHere, the derivative of the error is scaled and multiplied by the constant **Kd**.\n\nEach of the above components aims to correct different causes of the error, and together these three combine to give us the best desired output.\n\nLet‚Äôs understand the use of all the above three components using an example of a self-driving car. We have to design the controls of the vehicle. The car is supposed to move on a given marked line. Let's start with our analysis:\n\nThe input given to the car is to turn its steering wheel to left or right by a fixed angle, as shown below.\n\n![](/ERC-website-2021/static/image8.png)\n\nBut there is a problem with this; we are instructing to turn the steering wheel by the same angle even if the car is slightly offset. This will make the vehicle constantly oscillate around the line, and the ride will be jerky, making it uncomfortable for the passengers.\n\n![](/ERC-website-2021/static/image3.png)\n\nSo what can be done to solve this? We need to turn the steering wheel in proportion to the error, i.e., its offset from the line. This is where the P part comes into play. Notice what will happen if we give the input as: _u(t) = Kp e(t)_\n\n![](/ERC-website-2021/static/image2.png)\n\nHere we turn the steering by a smaller angle if the error is small and the problem is solved. But there is a problem with this too! This control works well with low offset, but it may lead to a situation like below when the error is high.\n\n![](/ERC-website-2021/static/image7.png)\n\nSince the initial angle is high, the steering angle is relatively high, but as a result, it leads to the car closing in on the line much quicker, even quicker than what the car can account for by decreasing the angle; hence it will overshoot. And again, the same story will repeat from the other side, leading to oscillations.\n\nSo how do we solve this? Here‚Äôs where the D part comes in handy. The input is modified as:  _u(t) = Kp e(t)  +  Kd e'(t)_\n\nThe added term takes into account the rate of change of error. So if the error is decreasing rapidly, _e'(t)_ will be highly negative. So when the error is enormous, the proportional part will be high, but as the car starts to steer, the derivative term will increase in the negative direction, avoiding the car to turn too quickly. So we will get an ideal situation as below:\n\n![](/ERC-website-2021/static/image4.png)\n\nThis is collectively known as **PD control**.\n\nWait! There is still a problem. Only P and D can lead to an error known as steady-state error. Take the following case: Let's say the car is driving at a small constant error parallel to the marked line (purple).\n\n![](/ERC-website-2021/static/image1.png)\n\nHow will the P and D act in this case? Since the error is small, the proportional part will steer through a slight angle, but as soon as it starts turning, _e'(t)_ will become negative and nullify the P term; hence the car will continue with a constant error (steady-state error).\n\nThe I part helps to account for this error. The input function now becomes:\n\n`u(t) = Kp e(t) + Kd e'(t) + Ki ‚à´e(t).dt`\n\nIntegral term adds the net error till the current time and tries to make it zero.\n\nSo here, the integral part will add up the steady-state error and slowly reduce the error.\n\nAs we can see from the above image, the initial small steady-state error is quickly reduced to zero using the _Integral_ term.\n\nThis completes our analysis of the **PID** control law. Note that the constants Kp, Kd  & Ki are tuned ample times to get the perfect combination of the three, such that none of them overshadows the other terms, and we get our desired output.\n\nSo we come to an end of this short introduction to Control Theory. It is a math-heavy topic, and this was quite a superficial picture. For those interested to learn further and reading more about Control theory, you may go through the Controls Theory Bootcamp conducted by ERC. It involves a mathematical approach which is needed for a deeper understanding of the topic. The link for it is [here](https://github.com/erciitb/tss-controls-theory \"here\").","slug":"controls-theory"},{"frontmatter":{"title":"PCB Designing with Autodesk Eagle","author":"Kaushal Jadhav","hero_image":"/ERC-website-2021/static/pcb_cover.png","date":"2021-11-24T12:30:00.000Z"},"markdownBody":"PCB is an acronym for Printed Circuit Board. It is a board with many lines and pads that connects various points together using conductive pathways. Traces are etched on copper sheets to make these pathways and the sheets are then laminated on a non-conductive substrate board.\n\n![How to Choose a PCB Assembly Company?](https://lh4.googleusercontent.com/pPgZQZbihhUpxO70xv9PP8EwR9tqFN4bv0JyNs_FkV0M-OHis0--nG1rluyRb1ExkmCoPCnXFK6aEDArU40f12HM8fnrjGDpwsZgz19pgvfUUK9ONSRHt_TlNq_Mcck_ZP-sDkH2 =342x228)\n\n# Why are PCBs so important?\n\nPCBs were invented in 1936.  \nLife before 1936:\n\n![Mass of wire wrap](https://lh4.googleusercontent.com/k8QxIDuiy4dlqQIjUFm6xYDOvnO7b6dFiFpxJzK34fGk60mvkfIz8ed9Hx01pMdKwQOMJ0KoJ7VAriNzQyHwjUZkjCL88MWg4sMDQuAU3vffApuFEahkDnhs87_LHYAb85touQ32 =335x248)  \nImagine you are an electrical engineer tasked with debugging this!  \nAnd don‚Äôt even get me started on maintaining such circuits\n\n# Composition and structure\n\nThe composition of a PCB is basically like a layered cake\n\n![](https://lh5.googleusercontent.com/oMSl3aE-kyobSGg9UTY7HhJkXdV4vSPOrtV5f02_px-4lru158l2XH23df4r8LDHs8R0hKX-JgrtdUAeUpfip2xCSzzMwR-2cUzrxy677ffz_61QQ7C8frMhwwo1Q9bb7r7dCGda =434x238)\n\n**Silkscreen:** The silkscreen adds letters, numbers, and symbols to the PCB that allow for easier readability.\n\n**Substrate (FR4):** The base material, or substrate, is usually fiberglass. This solid core gives the PCB its rigidity and thickness but keeps it flexible at the same time.\n\n**Soldermask:** This layer gives the PCB its distinctive green colour and is overlaid onto the copper layer to insulate the copper traces from accidental contact with other metal, solder, or conductive bits.\n\n**Copper:** Copper is laminated on both sides of the board with heat and adhesive. It electrically connects the electronic components and signals.\n\n# Understanding PCB terminology and basic terms\n\nNow that we‚Äôve got an idea of what a PCB structure is, let‚Äôs learn to read a PCB.\n\nPCBs involve a lot of overwhelming terminology and jargon. The good news is you don‚Äôt need to understand every bit of it. A basic understanding will suffice to start with.\n\nHere‚Äôs a link to a doc referring to the same:\n\n# Autodesk EAGLE\n\nThere are many PCB CAD softwares out there. But we will be covering EAGLE in this tutorial.\n\n_So what‚Äôs so special about EAGLE?_\n\nEAGLE is lightweight (50-200MB of disk space), free for students, has cross-platform support and most importantly has a great active community.\n\n**_Download, License and Install:_**\n\nEAGLE is free to [download](https://www.autodesk.com/products/eagle/free-download) and install with a student‚Äôs license. Create/Log-on to your Autodesk account with your college ID and grab the version that matches your operating system.\n\nEAGLE installs just like most programs. The download is an executable file; open it and follow the installation instructions. You can find the download link on A\n\n**_Libraries:_**\n\nIncluded with EAGLE is an impressive list of part libraries. These hundreds of libraries might be very useful for high end industrial PCB designing; but they end up becoming very overwhelming for us beginners.\n\nThe [SparkFun EAGLE libraries](https://github.com/sparkfun/SparkFun-Eagle-Libraries) are a good starting point. They are easy to understand and are also frequently updated.\n\nAfter downloading, navigate to Documents\\\\EAGLE\\\\libraries and paste the folder to add them to your resources.\n\n**_Creating your first project in EAGLE:_**\n\nAlright now, finally we can boot-up EAGLE and get started!\n\nWe'll start by making a new **project folder** for our design. In the control panel, under the \"Projects\" tree, right click on the directory where you want the project to live and select **\"New Project\"** and give it a nice descriptive name.\n\nThe project folder will house both our schematic and board design files.\n\nThese are the yin and the yang of EAGLE. They should be used together to create the finished product that is a functional PCB design.\n\n# The Schematic editor:\n\nTo add a schematic to a project folder, right-click the folder, hover over **\"New\"** and select **\"Schematic\"**. A new blank window will immediately pop-up.\n\nWelcome to the schematic editor!\n\nSchematic designing in EAGLE is like adding a few parts, wiring them, then adding some more and then wiring them again.\n\nAdding Parts to a Schematic\n\nThe ADD tool ![](https://lh6.googleusercontent.com/k5PoEdMk-eVCTfA2-nTYyK5npHUWP7jq6AakNp-e1hj5zmtG1bR8yhdTQWZRESGNkSd-5Vv5t6hWcHuBBwgyK3bEAmAmqlDRUUHYeXAkFP3yWK1ZA9V5Lj3i5B8Yvue0S2sxvUYs =28x27) opens up a library navigator, where you can expand specific libraries and look at the parts it holds. The most important functionality of the ADD tool is probably the search bar.\n\nThe search is very literal, so don't misspell stuff! A very crucial tip is the use of asterisks (*) before and after every component. This makes the search more lenient.\n\nFor example, if you search for _atmega328_ you should find a single part in the library, but if you search _*atmega328*_ (note asterisks before and after), you'll discover two more versions of the IC (because they're actually named \"ATMEGA328_P_\").\n\nAdd all the components, connectors and the power inputs using this tool.\n\nAfter placing the parts, if you need to move them around, use the MOVE tool -- ![](https://lh4.googleusercontent.com/P8BQ3vxngVCQXkJCUaASahbphHrgc7xPM9lV-3AqeLiEswaxa1v70AzOm9yW31TJANCv6kouIgvcvkpxNrR-hYb-fPG1xr4_xGUS1ewOYYBOXjRMTGWiY3aE_HMioHq7v3NN2fa3 =28x27)\n\n**_Wiring Up the Schematic:_**\n\nThere's one major caveat here before we start: even though we're wiring parts on the schematic, we not going to use the WIRE tool --![](https://lh6.googleusercontent.com/W0C69UpRUAJ_0oEcIT5FORb7mBBXMePNjBJ-YHHjr3ki0l4gpcTrYH8nfRCgdTIgoJSVl77Ayb-QzyoOQDBXlsqZVhrr5-sE01Ig_5qM_o88vumwfbXnXqbdZNLIFHxzDw7SKC87 =28x27) -- to connect them together. Instead, we'll use the NET tool -- ![](https://lh6.googleusercontent.com/jcvQigiJ3QWBj4P4Eez7eyGlZjuUiKHvX0Xcx6BGaG00EQJt2ICpYTOYwI42H5ABx42gBk65ER5SWGTqC6I5Xz6KhQm2PEUxfEa8BXVVQniIkzB1VQ09bD3747C4da7vFRF2nPT6 =28x27). The WIRE tool would be better-named as a line-drawing tool, NET does a better job of connecting components.\n\nHover over the very end of a pin (as close as possible, zoom in if you have to), and left-click once to start a wire. Now a green line should be following your mouse cursor around. To terminate the net, left-click on either another pin or a net. Start by routing the easiest and closest ones first.\n\nSuppose you encounter a pin that is to be connected to a component all the way on the other side. You could do it, it would work, but it'd be really ugly. Instead, we use the NAME tool -- ![](https://lh6.googleusercontent.com/IQmGO5O0q-aBz2OgCPJTEgFJASwPPhbYk9VmQ5qfMrDNxr4v_rkz0LdW6_mBf0JjZNcNHqA7UYq8IvEEq8orD1gxLHYs0a6bsSOapu92OFAUn99ZoSNAxpgNj013b99Zvg2APSYo =28x27) and the LABEL tool -- ![](https://lh5.googleusercontent.com/6MBpNnGmk-n6WKpkgFUpam_scRnM6sQXMm9NvSK8L7x4eIdSu7-QjhD3FUkFFq8E161-gxjaT7kfAXRf1uIG7WjYEHAOZ8gXeXPVrbmGvOsfgn2t7RW4MaKo4l0xeFzCFDdfMMVP =28x27).\n\nBegin by starting a net at a pin, just as you've been doing. Terminate the net by left-clicking a few grid-lengths over to the right of the pin. Then, instead of routing to another pin, just hit ESC to finish the route. With the NAME tool selected now click on the net and give it a short descriptive name. In the same way, create an unfinished net connected to the component and give it the same name as before. This should result in a warning dialog, asking you if you want to connect this net to all of the other nets with the same name. Thanks for looking out for us EAGLE, but in this case _Yes_ we do want to connect them.\n\nAfter naming a net, you should use the LABEL tool -- ![](https://lh5.googleusercontent.com/6MBpNnGmk-n6WKpkgFUpam_scRnM6sQXMm9NvSK8L7x4eIdSu7-QjhD3FUkFFq8E161-gxjaT7kfAXRf1uIG7WjYEHAOZ8gXeXPVrbmGvOsfgn2t7RW4MaKo4l0xeFzCFDdfMMVP =28x27) -- to add a text label for better readability.\n\nSome other useful tools:\n\n* The GROUP tool -- ![](https://lh5.googleusercontent.com/ZdURE3sdGkOQVKQvf2KUs7aInaOcNwODuJXOpK16pYSKgx6DeH5-rii4NGpOpp3gE_pSIpciQRZ_1rV_rmAfTDIyYO0Rhk5dN4oPgJytRhrcGfWwOGXZnAOkxrChceQ19fKfICxY =28x27)\n\nIn order to perform any action on a group, you have to select the tool, then **hold down CTRL** and **right-click the group**. After you CTRL+right-click, the tool will operate on the group just as it does a single component.\n\n* The SHOW tool -- ![](https://lh4.googleusercontent.com/gL737hdiBqI6CR5E_mEw3432TFPI1CZLjXQ_MkOL8sEMfJyKygQGapGxRbiqcn9A7MHN8OhfJqIcG7CCCKqpMOjWcTizaHaMoyUPQJb5kKkORvLBAPayYqHAbbh8FCI7HiiU8CX_ =28x26)\n\nIf you use SHOW on a net, every pin it's connected to should light up verifying that pins across your schematic are connected correctly.\n\n* COPY -- ![](https://lh5.googleusercontent.com/eSbYxy1vk9UFJe_jSodLidEW3TYCd_L18cSZV2OqP8DKek0BJmxtd6kiyt8OwC7x7iCZdnXKnlRzqBEXLqY3II2wytwRUjeZhpogSFUbK-ZXEqq1yS81BJYiA50QwjtJDgGpQGQ3 =28x27)-- and PASTE -- ![](https://lh4.googleusercontent.com/0tqi3vwAg3yCzZGDEE8Va3M6eXseircle1NcGRip1Mn7THDR9ma5SuAFU9SvbdjlrC0pcYfq1LEb1wMfj0xMCC-GygD6LhlYK0m38rMlBn2TYvsM7zdqRrRq36v4WN2xykMT-2E2 =28x27) -- tools\n\nEAGLE's Copy and Paste tools don't work exactly like other copy/paste tools you may have encountered before. Copy actually performs both a copy and paste when it's used while Paste can only be used to paste a **group** that has previously been copied to your clipboard.\n\n# The Board Editor:\n\nEAGLE's board designer is where a good portion of the magic happens.\n\nWhen you are done with the basic schematic of your design, simply click on the _Generate/Switch to Board_ command -- ![](https://lh3.googleusercontent.com/Ako4OgdlujI_tEPHxpviihwkrB_nvQCFr_EQPust6gAjACjNPpwbQ6jPjxWs5ylkkhTfdLCptyUk4RO8Ptt1QsfaCc-T9ZDGOHPHelEq1UD4hs8OqfaltV-7g_x9uB4GOR6cNMbR =28x27). A Board Editor window will open with all your parts stacked on one another connected with golden air-wires ready to be placed and routed.\n\nBefore getting started with laying down the components, it is imperative to first adjust the grid. Click on the GRID icon -- ![](https://lh5.googleusercontent.com/C18w6zVL38BzdvIYndBWt3uGENOZwDfhElO7Y9eXphUHI8ml8Xz3FdGKNWLzArn44mQPu4q0XpjmUgFiMP3INr-CtjmUNRnTNT8kBu0bL96CkdemhXCFxASfjYZnxgxIoAFkOV8T =28x27) and adjust the size. Generally, a 0.05\" grid, and 0.005\" alternate grid is a good size but do check it according to your specific requirements.\n\n**_Laying the Board:_**\n\nUse the MOVE tool ![](https://lh4.googleusercontent.com/P8BQ3vxngVCQXkJCUaASahbphHrgc7xPM9lV-3AqeLiEswaxa1v70AzOm9yW31TJANCv6kouIgvcvkpxNrR-hYb-fPG1xr4_xGUS1ewOYYBOXjRMTGWiY3aE_HMioHq7v3NN2fa3 =28x27) to arrange your parts, right-clicking will rotate the part. The way you arrange your parts has a huge impact on how easy or hard the next step will be.\n\nHere are a few things to keep in mind:\n\n* **Don‚Äôt overlap parts**: All parts need to have some clearance between them to ensure the signals don‚Äôt short circuit.\n* **Minimize intersecting air-wires**: Limiting criss-crossing air-wires will make routing _much_ easier in the long run.\n* **Part placement requirements**: Some parts may require special considerations like the power connector will always be placed on the edge of the board.\n* **Cost vs. Effort: The tighter your board is the cheaper it is, but it also makes routing that much harder.**\n\n**_Routing the Board_**\n\nRouting is probably the most fun part of PCB designing. It‚Äôs almost like solving a puzzle.\n\nClick on the ROUTE tool and route away! On a 2-layer board, you can route the wires in either red or blue colour. Each colour specifying a different copper layer that you can switch using your middle-mouse button. You can also change the Bend style and Width of your routes. Usually, you will want to keep it 45 degrees and 0.01‚Äù.\n\n![Good and bad trace overlaps](https://lh6.googleusercontent.com/MP6o88Q6_ExU_Y0QXM8REQptg0CWrnPnssw2nifoUYJqkdpwbRUjmcKEpnXOQ2MdLI58Yw37_EYAju13DZXnE0xkkaxgcxUD3ISw6YXr7bGDQbQ5stHWzbDqhTovvfu4drM3x4FC =409x290)\n\nAnother important thing to remember while routing is to avoid overlaps of any sort. If traces do cross each other on opposite sides of the board, it's perfectly. That's why there are two layers!\n\n**_Vias:_**\n\nVias are a cool workaround to avoid overlaps. It allows you to travel between the red and blue layers. But don‚Äôt get carried away because more vias mean more money.\n\n**_The Alternate grid:_**\n\nIf you need more precision, hold down the ALT key to access the alternate grid. But do make sure to keep enough route clearance. A good rule of thumb is to keep enough space between two routes to run another one between them.\n\n**_The Auto-Router:_**\n\nCheater! If you are short on time or having trouble routing the PCB yourself you can use EAGLE‚Äôs Autorouter ![](https://lh6.googleusercontent.com/owphrvcuSYLP0G2PihibXaoaVVgVV7Aq8sVQpZfItKKkGYmo1vGBmra2U7LIW2J4XnIZcVm8PXgXzjQ7Vma2NvtZvDhfr2ESuSnYhSKPVMJU50lZ6wq8XQmCRQNqy7RaRPn5Q_1G =28x27). It gets the job done but has no regard for your cost constraints.\n\n**_Checking for Errors:_**\n\nThere are two checks to perform before we can package the PCB and send it to the fabrication house.\n\n1. **Ratsnest:**\n\nThe RATSNEST tool ![](https://lh5.googleusercontent.com/VLSDUeSNsfoC84yb_TAvGEQgK2wjKWPEUTvBnaDBrLI-sCK1zPI48-xfq0Dq17RIivg3CGjd1L5qlKt2G9ZP8FyLLAkeSNrUUvtCfiupLVyQdw81mEfsSJiJhxbtZVAQ59PXGw0b =28x27) checks if you have routed everything and say the sweetest words a PCB designer can ever hear: ![Ratsnest -- Nothing to do!](https://lh6.googleusercontent.com/cDTtzXPpdfYWXTIAYW8eMC2PPXVagozMudpzIu183yrHJNhQHFapW2_b04WpmJvRD1upO80a67mOrNulxnbA2SFElUnBk2xbzsIcFfO0j051bWUCfLM88K16wJVwI-8ryASYDBUZ =330x28)\n\n2. **Design Rule Check (DRC)**\n\nThe DRC ![](https://lh6.googleusercontent.com/PYkCCWrKpUe_fu1QxoGDbzcWiYsI36jzD1Wuldymxxf-yr30ljuYgk--QjFmk0PT0v4U0B8WtwzpJGvVG8vTlHcb042jIscQETD9VO4TleSjry378GOui46TG2O7cQxL0XaRSL0V =28x27) can provide all sorts of errors like if a trace is too close to either another trace or a via, or two different signal traces are overlapping each other or even if a trace, pad, or via is intersecting with (or too close to) a dimension line.","slug":"pcb-designing-with-autodesk-eagle"},{"frontmatter":{"title":"Sensor Fusion","author":"Govind Saju","hero_image":"/ERC-website-2021/static/fusion_sensors_cover.jpg","date":"2021-11-24T12:30:00.000Z"},"markdownBody":"Sensor Fusion refers to the process of combining measurements from different sources to ensure that resulting information has lesser uncertainty as compared to any of the individual measurements. As an example, we can calculate depth information from 2-D images by combining data from 2 cameras at slightly different locations.\n\nThe different sources for the information we obtain need not be identical. There are three types of fusion methods:\n\n* **Direct Fusion:** Fusion of data from a set of either heterogenous or homogenous set of sensors along with past history of sensor data\n* **Indirect Fusion:** Along with sources in direct fusion, we also use sources like a priori knowledge about the information, and human input.\n* **Combination of both:** We can also obtain information by combining the outputs of the above 2 methods of fusion\n\n# Classification of Sensor Fusion Algorithms\n\nSensor Fusion algorithms can be classified on different parameters:\n\n## On the basis of Abstraction Level (When?)\n\n* **Low Level Fusion:** Fusing the raw data coming in from different sensors\n* **Mid Level Fusion:** Fusing the detections from each sensor\n* **High Level Fusion:** Fusing the trajectories (predictions) of each sensor\n\n![](/ERC-website-2021/static/fusion_sensors_image3.png)\n\n## On the basis of Centralization Level (Where?)\n\n* **Centralized:** A single central unit deals with the fusion\n* **Decentralized:** Each sensor fuses the data and sends it onto the next one\n* **Distributed:** Each sensor fuses data locally and sends it to the next unit\n\n![](/ERC-website-2021/static/fusion_sensors_image2.png)\n\n## On the basis of Composition Level (What?)\n\n* **Competitive Fusion:** When different sensors are meant for the same purpose\n* **Complementary Fusion:** When different sensors are used to look at different scenes to obtain data that couldn‚Äôt have been obtained had the been used individually\n* **Coordinated Fusion:** Using multiple sensors to produce a new scene, but looking at the same object. E.g. 3D reconstruction\n\n![](/ERC-website-2021/static/fusion_sensors_image1.png)\n\nFor more details regarding the types of sensor fusion, check [here](https://www.thinkautonomous.ai/blog/?p=9-types-of-sensor-fusion-algorithms \"https://www.thinkautonomous.ai/blog/?p=9-types-of-sensor-fusion-algorithms\").\n\n**Example Calculation Regarding Sensor Fusion**\n\nFor a basic example showing how two measurements can be combined, check [this](https://en.wikipedia.org/wiki/Sensor_fusion#Example_calculations \"https://en.wikipedia.org/wiki/Sensor_fusion#Example_calculations\") section.\n\n# Algorithms on Sensor Fusion\n\n## Based on Sensor Fusion\n\n* The central limit theorem states that when we take a large number of measurements of a parameter, the distribution of their mean tends to a normal distribution, and the mean of the distribution gets closer to the true mean as number of measurements increase.\n* In order to see its relation to sensor fusion, assume we have two different sensors A and B. The more samples we take of their readings, the more closely the distribution of the sample averages will resemble a bell curve and thus approach the set‚Äôs true average value.  The closer we approach an accurate average value, the less noise will factor into sensor fusion algorithms.\n* For more information regarding the central limit theorem, check [here](https://en.wikipedia.org/wiki/Central_limit_theorem \"https://en.wikipedia.org/wiki/Central_limit_theorem\").\n\n## Based on Kalman Filter\n\n* A Kalman filter is an algorithm that estimates unknown values by taking data inputs from multiple sources, despite possibly having a high amount of signal noise.\n* It has the advantage of predicting unknown values more accurately by combining measurements than what is obtained on using the measurements individually.\n* The Kalman filter is a recursive algorithm that depends only on the previous state of the system and the current observed sensor data to estimate the current state of the system.\n* For more details regarding the Kalman filter, check [here](https://www.kalmanfilter.net/default.aspx \"https://www.kalmanfilter.net/default.aspx\") or [here](https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/ \"https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/\").\n\n## Based on Bayesian Networks\n\n* Bayes Rule in probability is the backbone of state update equations used for sensor fusion. Bayesian Networks based on Bayes rule predicts the likelihood that any given measurement is a contributing factor in determining a given parameter.\n* For a detailed study of Bayesian Networks, check [here](https://en.wikipedia.org/wiki/Bayesian_network \"https://en.wikipedia.org/wiki/Bayesian_network\").\n* Some of the algorithms used for Sensor Fusion based on Bayesian networks are [K2](http://web.cs.wpi.edu/\\~cs539/s05/Projects/k2_algorithm.pdf \"http://web.cs.wpi.edu/~cs539/s05/Projects/k2_algorithm.pdf\"), [hill climbing](https://www.geeksforgeeks.org/introduction-hill-climbing-artificial-intelligence/ \"https://www.geeksforgeeks.org/introduction-hill-climbing-artificial-intelligence/\"), [simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing \"https://en.wikipedia.org/wiki/Simulated_annealing\").\n\n## The Dempster-Shafer Theory\n\n* This theory, called the theory of belief functions or the evidence theory, is a general framework for working with uncertainties and measurements.\n* Dempster‚ÄìShafer theory is based on two ideas: obtaining degrees of belief for one question from subjective probabilities for a related question, and Dempster's rule for combining such degrees of belief when they are based on independent items of evidence.\n* For more details on this theory, check [here](https://en.wikipedia.org/wiki/Dempster%E2%80%93Shafer_theory \"https://en.wikipedia.org/wiki/Dempster%E2%80%93Shafer_theory\") or [here](https://www.geeksforgeeks.org/ml-dempster-shafer-theory/ \"https://www.geeksforgeeks.org/ml-dempster-shafer-theory/\").\n\n## Convolutional Neural Networks\n\n* Convolutional neural network based methods can simultaneously process many channels of sensor data. From this fusion of such data, they produce classification results based on image recognition.\n* For a detailed study of CNNs, check [here](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53 \"https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53\").\n\n# Conclusion\n\nSensor Fusion is a vast field, with a huge number of algorithms to combine sensor data to obtain measurements. The mathematics behind sensor fusion is often complicated and requires a good understanding of concepts of probability. The goal of this article was to give a brief overview of different types of sensor fusion and to give a bird‚Äôs eye view of the various algorithms that can be used for sensor fusion.","slug":"sensor-fusion"},{"frontmatter":{"title":"SLAM","author":"Govind Saju","hero_image":"/ERC-website-2021/static/slam_cover.jpg","date":"2021-11-24T12:30:00.000Z"},"markdownBody":"The objective of SLAM is to estimate a robot‚Äôs state (position and orientation) and create a map of the robot‚Äôs surroundings simultaneously using the knowledge of its controls and the observations made by its sensors.\n\n# Introduction\n\nThe term SLAM is an acronym for ‚ÄúSimultaneous Localization and Mapping‚Äù.\n\n**Localization**: Localization refers to the robot's ability to estimate its own position and orientation with respect to its surroundings. This is done by combining the robot's controls along with the data obtained from its sensors.\n\n**Mapping**: Creating a map of the robot‚Äôs surroundings using its estimate on its position and the data obtained from various sensors.\n\nSLAM aims to do both of these tasks simultaneously, using one to help improve its estimate of the other. This may not sound possible, but there are various algorithms like [Kalman filter](https://en.wikipedia.org/wiki/Kalman_filter), [Particle filter](https://en.wikipedia.org/wiki/Particle_filter), and [GraphSLAM](https://people.eecs.berkeley.edu/\\~pabbeel/cs287-fa13/slides/GraphSLAM.pdf) that help provide an approximate solution in certain environments to both these problems.\n\nThe general idea of slam can be subdivided into different stages:\n\n* Landmark Extraction\n* Data Association\n* State Estimation\n* State Update\n* Landmark Update\n\n![](/ERC-website-2021/static/slam_image11.jpg)*_In the image above, EKF stands for Extended Kalman Filter, an algorithm used for implementing SLAM._\n\nSLAM is an idea through which we estimate the robot‚Äôs state through its controls, and using the locations of the landmarks we witness, we improve the estimate of the robot's state. It is based on a probabilistic model, where each item has a probability of being in a particular position.\n\n# Applications of Slam\n\n![](/ERC-website-2021/static/slam_image10.png)\n\nSLAM is used extensively in various indoor, outdoor, aerial, underwater and underground applications for both manned and unmanned vehicles.\n\nFor e.g. Reef monitoring, exploration of mines, surveillance drones, terrain mapping etc.\n\n# Probabilistic Interpretation of SLAM\n\nIn the probabilistic world, each measurement and estimate has some error associated with it, and we can only determine a probability distribution to estimate the map and localisation of a robot using SLAM. Mathematically, it can be represented as:\n\n![](/ERC-website-2021/static/slam_image14.png)\n\nThis means that the objective of SLAM is to obtain the probability distribution of the robot‚Äôs path and a map of its surroundings using the knowledge of the robot‚Äôs controls and the observations it makes using its sensors.\n\nBelow is a graphical representation of SLAM. **xt** is the location of the robot at time t, **m** represents the map, **ut** represents the controls of the robot at time t, and **zt** represents the values observed by the sensors on the robot.  \n![](/ERC-website-2021/static/slam_image6.png)\n\n# Homogeneous Coordinates\n\nIn SLAM, cameras are often used as sensors to obtain information about the robot's surroundings. Cameras don‚Äôt capture a 3D image, rather they capture a projection of the 3D world. The mathematical formulations can become simpler if we use projective geometry instead of euclidean geometry. The system of coordinates used in projective geometry is called homogeneous coordinates. The details regarding the mathematics of homogeneous coordinates can be found [here](https://en.wikipedia.org/wiki/Homogeneous_coordinates).\n\n# Bayes Filter\n\nA lot of the different models used for SLAM such as the Kalman Filter and the Particle Filter are based on the Recursive Bayes Filter. In the Bayes filter, the **belief** of **xt** is defined as\n\n![](/ERC-website-2021/static/slam_image8.png)\n\nThe recursive Bayes Filter can then be defined as a 2 step process:\n\n* Prediction Step\n\n  ![](/ERC-website-2021/static/slam_image12.png)\n* Correction Step  \n  ![](/ERC-website-2021/static/slam_image1.png)\n\n**_p_(_xt | ut_, _xt-1_)** represents the motion based model, which is the distribution of the current location based on the robot‚Äôs controls and its previous location. **_p_(_zt_ | _xt_)** represents the correction introduced based on the sensor readings **_zt_**. This Bayes filter acts as a framework for different realizations such as the Kalman Filter and the Particle Filter. For further details regarding the Bayes Filter, refer [here](https://en.wikipedia.org/wiki/Recursive_Bayesian_estimation).\n\n# Motion Models\n\nIn the section of Bayes Filter, we saw the term **_p_(_xt | ut_ , _xt-1_)** represents the motion based model. In general, there are 2 common types of motion based models:\n\n* Odometry based model\n* Velocity based model\n\nThe Odometry based model is mainly used for those robots that have wheel encoders, i.e. where it is feasible to count wheel motions and find the direction of motion. The Velocity based model is normally used where the odometry based model cannot be implemented, e.g. a drone does not have wheels and wheel encoders cannot be used. For a detailed description of the 2 models here including their mathematical formulations, check [this](https://ccc.inaoep.mx/\\~mdprl/documentos/CH5.pdf) document.\n\n# Sensor Models\n\nThe term **_p_(_zt_ | _xt_** **)** represents the sensor based model. It represents the probability distribution of getting a measurement **_zt_** at a position **_xt ._** There can be different kinds of sensors used.\n\n* Internal sensors such as gyroscopes, accelerometers etc\n* Proximity sensors such as Sonar, Radar etc.\n* Visual Sensors like cameras\n* Satellite based sensors like GPS\n\nFor more details regarding the Sensor Models, refer to [this](http://ais.informatik.uni-freiburg.de/teaching/ss09/robotics/slides/e_sensor-models.pdf) document.\n\n![](/ERC-website-2021/static/slam_image2.jpg)\n\n# Filters\n\nThere are 2 main methods used for implementing SLAM, that is the Kalman Filter and the Particle Filter. They are based on the Bayes Filter and use the motion and sensor models to get a good estimate for SLAM.\n\n# The Kalman Filter\n\nThe Kalman filter is a filter based on the Bayes filter, and is the optimal solution for the linear Gaussian case. It assumes all probability distributions are gaussian. For a complete tutorial on Kalman filter, check [here](https://www.kalmanfilter.net/default.aspx). In short, the Kalman filter can be depicted as follows:\n\n![](/ERC-website-2021/static/slam_image3.png)![](/ERC-website-2021/static/slam_image5.png)\n\n# Particle Filter\n\nThe particle filter is also based on the Bayes filter, but it is superior to the Kalman filter in non-linear and non-Gaussian systems. The particle filter models by samples, and the more samples, the better the distribution.\n\n![](/ERC-website-2021/static/slam_image4.png)![](/ERC-website-2021/static/slam_image7.png)  \nFor more details regarding the particle filter, check [here](https://en.wikipedia.org/wiki/Particle_filter) or [here](http://ais.informatik.uni-freiburg.de/teaching/ws13/mapping/pdf/slam11-particle-filter.pdf).\n\n# Further Reading\n\nFor tutorials on the Kalman Filter: check [here](http://www.kalmanfilter.net) or [here](https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/).\n\nFor a reading on the Particle Filter: check [here](https://towardsdatascience.com/particle-filter-a-hero-in-the-world-of-non-linearity-and-non-gaussian-6d8947f4a3dc) or the resources mentioned in the particle filter section.\n\nFor a reading on the Extended Kalman Filter, check [here](https://en.wikipedia.org/wiki/Extended_Kalman_filter).\n\nFor a complete course on SLAM including slides and recordings from the University of Freiburg, check [here](http://ais.informatik.uni-freiburg.de/teaching/ws13/mapping/).","slug":"slam"}],"title":"ERC: Blog","description":"Electronics and Robotics Club, IIT Bombay's Blog"},"__N_SSG":true}
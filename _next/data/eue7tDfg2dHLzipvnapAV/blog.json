{"pageProps":{"allBlogs":[{"frontmatter":{"title":"Arduino","author":"Tejas Amritkar","hero_image":"/ERC-website-2021/static/arduino_cover.jpg","date":"2021-11-24T12:30:00.000Z"},"markdownBody":"# What is Arduino?\n\n* Open-source Electronics prototyping platform\n* Uses a ‚Äúmicroprocessor‚Äù/‚Äùmicrocontroller‚Äù\n* Programmable in language similar to C\n* Implements many inbuilt functions\n* Multiple sensors available for use\n* Lots of support online - very popular\n\nThere are different Arduino Boards available in the market like Arduino UNO (R3), Arduino Nano, Arduino Mega (R3), etc. We will focus on **Arduino UNO R3** in this tutorial.\n\n# Programming Arduino\n\n* Arduino uses its own IDE (Integrated Development Environment) to write programs.\n* Setting up and programming Arduino : [Arduino](https://www.youtube.com/watch?v=fJWR7dBuc18 \"Arduino Setup\")\n\n# Arduino UNO\n\n## Arduino pins\n\nIf you want detailed info on any of the pins , you can visit here:  \n[robotics backend/arduino-uno-pins](https://roboticsbackend.com/arduino-uno-pins-a-complete-practical-guide/)\n\n![](/ERC-website-2021/static/arduino_image2.png)\n\n1 - USB CONNECTOR  \n2 - POWER JACK  \n3 - GROUND PINS  \n4 - 5V PINS  \n5 - 3.3V PINS  \n6 - ANALOG INPUT PINS  \n7/8 - DIGITAL PINS- out of the 14 Pins, 6 can be used for PWM (denoted by \\~)  \n9 - ANALOG REFERENCE  \n10 - RESET BUTTON  \n11 - POWER LED  \n12 - TX/RX LEDS  \n13 - ATMEGA328P  \n14 - VOLTAGE REGULATOR\n\n## Power Pins\n\n![](/ERC-website-2021/static/arduino_image1.png)\n\n* Vin is the input voltage to the board when it‚Äôs using an external power source (as opposed to 5 volts from the USB connection or other regulated power source from the power jack)\n* You can supply voltage through this pin(from external circuitry), or, if supplying voltage via the power jack, access it through this pin.\n* This is how you power the board when it‚Äôs not plugged into a USB port for power. Can accept voltages between 7-12V(But the voltage is regulated to a maximum of 5V)\n\n## LEDs\n\n* **Pin 13 LED:** The only actuator built into the board. Useful for debugging, since the LED is in-built and hence reliable in terms of connections.\n* **Power LED:** Indicates that the board is receiving power. Useful for debugging.\n* **Reset button:** Resets the ATmega microcontroller.\n* **TX and RX LEDs:** Indicate communication(send/receive) between the board and the computer. Flicker rapidly during sketch upload as well as during serial communication. Useful for debugging.\n\n## USB Port\n\n* Used for the board, and most importantly, uploading your sketches to the board.\n* Also used for communicating with the sketch (via Serial.println() etc).\n\n## Digital Pins\n\n![](/ERC-website-2021/static/arduino_image8.png)  \nDigital **Input/Output** pins(0,1 are serial in/out) are numbered from 2-13  \nHigh(5V) or Low(0V)  \nDigital reading pins ( for input V < 0.8 => low; V > 2 => high)\n\n**Arduino LED:**\n\nExample 1:  \nLet‚Äôs make the LED blink, which means that we are going to :\n\n1. Power in the LED\n2. Wait\n3. Power off the LED\n4. Wait\n5. Go back to 1\n\nSee the code here : [Example1](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#example-1)\n\n![](/ERC-website-2021/static/arduino_image3.png)\n\n**digitalWrite(Pin_no, HIGH/LOW);**  \nHIGH sets the pin to give a 5V (high) output while a low sets the pin to give a 0V output.  \nOnly to assign the value to the output pins.\n\n**digitalRead(Pin_no);**  \nGives the reading of the digital input pin as a high or a low.\n\n## PWM Pins\n\nPWM enabled pins(3,5,6,9,10,11) can also be used as Analog **Outputs** (represented by \\~)  \nanalogWrite(LED_PIN, n); **n** can take values from **0 to 255**.\n\nIn the Example1 replacing line digitalWrite(LED_PIN, HIGH); with analogWrite(LED_PIN, 102); will cause 102/255 ie. 40% of maximum voltage( 5V) across circuit.  \n(can be used to change the brightness of the LED in this example)\n\nExample 2:  \nLet‚Äôs make the LED fade in (which means the brightness will slowly increase until the max), and then fade out (brightness will slowly decrease), so we can create a nice effect with the LED.  \nSee the code here : [Example2](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#example-2)\n\n## Analog Pins\n\n![](/ERC-website-2021/static/arduino_image14.png)\n\n**analogRead(Pin_no);  \n**Reads the input from the analog pins marked as A0,A1...A5 on the arduino board. This reading is a 10 bit value (0-1023).\n\nLet's say Arduino is reading 2V.  \n2V is 40% of 5V (Vcc). In your Arduino program, you will then get the value 409 ( 40% of 1024 ). From this value, you can easily reverse the computation and get the information about the voltage that was applied.\n\n## Serial Communication\n\nSerial is used for communication between the Arduino board and a computer or other devices. All Arduino boards have at least one serial port (also known as a UART or USART). It communicates on digital pins 0 (RX) and 1 (TX) as well as with the computer via USB. Thus, if you use these functions, you cannot also use pins 0 and 1 for digital input or output.\n\n**Arduino Serial port and Print Commands:  \n**See the example here : [Example 3](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#example-3)  \nOpen the Serial monitor ( on top right corner)\n\nSerial.begin(baud_rate);  \nSets the data rate in bits per second (baud) for serial data transmission. Settable to 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600 or 115200 baud rate defined here and that selected on the serial monitor should be the same.\n\nSerial.end();  \nDisables serial communication, allowing the RX and TX pins to be used for general input and output.\n\nif(Serial);  \nIndicates if the specified Serial port is ready.\n\nSerial.available();  \nGet the number of bytes (characters) available for reading from the serial port.\n\nSerial.read();  \nReads incoming data\n\nSerial.print(j);  \nprint on the same line\n\nThere are many serial functions that have not been covered in the previous segment, but they are important for some specific uses.  \n[https://www.arduino.cc/en/reference/serial](https://www.arduino.cc/en/reference/serial \"https://www.arduino.cc/en/reference/serial\")\n\n**Reading data from serial monitor :  \n**Example 4 : Tell the Arduino how many times you want to blink LED  \nSee the code here: [Example 4](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#exmaple-4)\n\n## Interrupt Pins\n\nPurpose - Stop the continuous progress of an activity or process.  \nInterrupts triggers a function inside the Arduino code. This stops the main execution of your program. After the triggered function is done, the **main execution resumes**.\n\n**Digital Pins 2, 3** are Interrupts pins.\n\nBefore going through the example, lets introduce the **push button**. You should notice which pins are internally connected and which are not.\n\n![](/ERC-website-2021/static/arduino_image4.jpg)\n\n**Example 5:** The goal of the Example is to change the state of a LED when the the user presses a push button.\n\nPart 1 : Arduino code without interrupts  \nSee the code here : [Example5_Part1](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#part-1)\n\nPart 2 : Arduino code with Interrupts  \nSee the code here : [Example5_Part2](https://github.com/Tejas2910/Getting-started-with-Arduino/blob/main/README.md#part-2)\n\n![](/ERC-website-2021/static/arduino_image6.png)\n\n**Note** : Make the interrupt function as fast as possible, because it stops the main execution of your program.\n\n**Volatile Variables :**\n\nIf you modify a variable inside an interrupt, then you should declare this variable as volatile.\n\nThe compiler does many things to optimize the code and the speed of the program. This is a good thing, but here we need to tell it to ‚Äúslow down‚Äù on optimization.\n\nFor example, if the compiler sees a variable declaration, but the variable is not used anywhere in the code (except from interrupts), it may remove that variable. With a volatile variable you‚Äôre sure that it won‚Äôt happen, the variable will be stored anyway.\n\nNote that only variables that are used inside and outside an interrupt should be declared as volatile. You don‚Äôt want to unnecessarily slow down your code.\n\nIf you want to get deeper into Interrupt pins, check this out : [arduino-interrupts](https://roboticsbackend.com/arduino-interrupts/)\n\n# Peripherals\n\nArduino supports multiple peripherals like:\n\n* Ultrasonic Sensor\n* LCD\n* Bluetooth\n* Pressure Sensor\n* Accelerometer/Gyrometer\n* RTC module\n* SD card\n* LDR sensor\n* Temperature sensor\n\n## Ultrasonic Sensor\n\n* This sensor sends out pulses from T, which bounce off from the object and R receives them.\n* When the receiver gets the U.S. pulses, it generates a high signal. We get the time difference between the pulses which is used to calculate the distance\n* The speed of sound is approximately 341 meters (1100 feet) per second in air.\n* **Distance = (Time x Speed of Sound)/2**\n\n![](/ERC-website-2021/static/arduino_image15.png)\n\nUseful Function:  \npulseIn(Pin_no, HIGH);  \nGives the time in milliseconds from the time this command is initiated until Pin_no gives a HIGH pulse.\n\n**Sample:**\n\n* Initialise variables before setup()\n* Sets the data rate of data received from the board using Serial.begin() and sets the trig pin to OUTPUT and echo pin to INPUT.\n* First three lines of loop() send out a trigger pulse on the trig pin to cause the sensor to emit an ultrasound pulse.\n* pulseIn(echo, HIGH) records the time after which the echo pin receives a HIGH pulse.\n* Data is converted into distance in cm and printed to the Serial monitor.\n\n**Exercise:**\n\nHow to measure distance using Ultrasonic sensor **HC-SR04  \n**[using an Ultrasonic sensor](https://create.arduino.cc/projecthub/knackminds/how-to-measure-distance-using-ultrasonic-sensor-hc-sr04-a-b9f7f8) (Error in pin mapping)  \nNote (TRIG connection of the sensor attached to digital **pin 12  \n**ECHO connection of the sensor attached to digital **pin 13**)\n\n## LCD\n\nWhy is the LCD used?  \nTo display certain information or data on the screen. They are useful for debugging when you cannot use a laptop or serial monitor.\n\n![](/ERC-website-2021/static/arduino_image9.png)![](/ERC-website-2021/static/arduino_image13.png)\n\n**Functions:**\n\n* lcd.begin(16,2): This declares the size of LCD\n* lcd.clear(): Clears the LCD\n* lcd.setCursor(0,0): Moves the cursor to (0,0) of the array\n* lcd.print(‚Äúhello world‚Äù): Prints whatever is in the bracket\n\n**Exercise:**\n\nWrite code to display the distance directly onto the LCD  \nFor more information visit : [Liquid_Crystal_Library](https://www.arduino.cc/en/Reference/LiquidCrystal)\n\n## Infrared Sensor\n\n![](/ERC-website-2021/static/arduino_image10.png)\n\n* I.R. sensor is used as a proximity sensor or collision sensor (not exact distance).\n* TX which emits IR light continuously.\n* So, when an object is near the sensor light is reflected into the RX which creates a voltage difference.\n* The generation of this voltage difference depends on the intensity of IR light received by the RX\n* **Note: You cannot use IR sensors outdoors or in bright lights because the IR light of the sun or from the bulb interacts with the RX. Use US sensors instead.**\n\n  ![](/ERC-website-2021/static/arduino_image16.png)\n\n**IR Sensor People Counter  \n**To make a device which counts the number of people entered, excited and present in the room using an IR sensor.\n\n![](/ERC-website-2021/static/arduino_image12.png)![](/ERC-website-2021/static/arduino_image7.png)\n\n**Example**\n\n* For an Arduino UNO we can only send one byte at a time and hence we will communicate between the two arduinos using characters ‚ÄúH‚Äù and ‚ÄúL‚Äù. (We can do this using numbers as well)\n* One Arduino will serve as a sender while the other will be a receiver. The communication will take place through the set of Serial() functions.\n\n## Bluetooth Module\n\n![](/ERC-website-2021/static/arduino_image5.jpg)\n\nHere is our Bluetooth Module with its Pinout.  \nThe Bluetooth Module will communicate with Arduino via Tx / Rx Pins (Pin1/Pin0) present on Arduino,as we used second Arduino in above communication.  \nPs:We Only Need **Vcc,Gnd,Tx,Rx** Pins For Such Communication.\n\n![](/ERC-website-2021/static/arduino_image11.png)\n\nArduino bluetooth basic tutorial: [working on bluetooth module](https://create.arduino.cc/projecthub/mayooghgirish/arduino-bluetooth-basic-tutorial-d8b737)\n\n# Arduino Communication Protocols\n\nThree Protocols for device communication :\n\n1. **UART** - Universal Asynchronous Receiver/Transmitter\n2. **SPI** - Serial Peripheral Interface\n3. **I2C** - Inter-integrated circuit\n\nDetails can be seen here : [Arduino-communication-protocols](https://www.deviceplus.com/arduino/arduino-communication-protocols-tutorial/)","slug":"arduino"},{"frontmatter":{"title":"Controls Theory","author":"Pranav Malpure","hero_image":"/ERC-website-2021/static/controls_theory_cover.jpg","date":"2021-11-25T13:50:00.000Z"},"markdownBody":"_Control theory is a branch of mathematics and engineering, which defines the conditions needed for a system to maintain a controlled output in the face of input variation_. In simple terms, we seek to stabilize our system through some control theory concepts when many factors can destabilize it. At the end of reading this article, you can expect to have an overview of control theory with some basic knowledge of PID control.\n\nTo understand this, first, let us know a few terms:\n\n1\\. **Input:** The set of instructions given to the system\n\n2\\. **Output:** Consists of a group of variables that describe the state of the system. Usually represented by ùë•\n\n3\\. **Control System:** The entire system, which includes a _controller_, _plant_, and _sensors_, is collectively known as a control system. The _plant_ is a part that is controlled. The _controller_ provides control commands to the plant. _Sensors_ measure the state of the system. See the flow diagram for reference:\n\n![](/ERC-website-2021/static/image9.png)\n\nTo put these terms into an application, let‚Äôs take the example of a person driving a car. (Pause here and try to identify what could be the input, output, and control system in this example.) So, in this case, the _input_ could be instructions given to the driver by his brain. The driver will be the _controller_, which controls the car using the instructions received. The vehicle will be the _plant_; sensors would be the speedometer, driver‚Äôs eyes to see the traffic, ears to listen to any horn, etc. The _output_ could be the velocity of the car, current traffic conditions on the road, etc.\n\nNow that you understand basic terms let's move on to classifying control systems.\n\nWe classify control systems on various bases, but the most prominent ones are:\n\n## 1. Based on feedback (output)\n\n* **Open-loop control system** - In this type of system, the input given to the controller is independent of the output. In the above car example, we can see that if the driver doesn‚Äôt pay heed to the current state of the system(the output) and drives it just based on some pre-learned instructions, then this system would be an open loop, as there are no changes made to the input depending on the output. As you must have noticed, this type of system is problematic as it cannot account for any uncertainties.\n* **Closed-loop control system** - Here, the input commands are based on the output received. For example, when a car stops in front, the driver‚Äôs input will change, and they will apply brakes.\n\n## 2. Based on energy expenditure\n\n* **Active** - In this type, a certain amount of energy is required to implement the control commands. For example, to accelerate the car, it will consume fuel.\n* **Passive** - This system involves minimal energy expenditure to implement the input into the system. For example, if the car goes downhill, it can be controlled by just applying the brakes.\n\nSince we now have an overview of control theory, let us bring some maths into the picture, let the input function be _u(t)_ and output function be _x(t)_.\n\nWondering what use maths is of? Read on...\n\n# Control Law\n\nVarious types of systems have different anomalies present in them. In many cases, we can express the output and correction to the input to control the system through some mathematical relation. This relation is known as a _control law_. So, a _control law_ is a mathematical law that relates output and input, along with other control command parameters or measurable properties of the state.\n\nExample:   \t\tu(t) = -K(x(t) - x0)\n\nThere are various control laws, such as _Linear Quadratic Regulator_ (the above example is an LQR), _PID control_, etc., which may be helpful in different scenarios. One such law is PID which is widely used even in industries because it is simple and works for almost every case.\n\n# Proportional-Integral-Derivative (PID)\n\nThe control law for PID is:\n\n![](/ERC-website-2021/static/image5.png)\n\nDon‚Äôt get overwhelmed with the equation! It‚Äôs pretty simple when you understand it.\n\nLet us understand what each term is:\n\n1\\. **Kp** is the proportional coefficient/weight\n\n2\\. **Kd** is the derivative coefficient/weight\n\n3\\. **Ki** is the integral coefficient/weight\n\n4\\. **Ti** is the integral time constant\n\n5\\. **Td** is the derivative time constant\n\nHere, _e(t)_ is the error between the desired and the actual state.\n\nThis law has three parts: **proportional**, **integral** and **derivative** parts; each one of them has its own importance.\n\n**Proportional(P)**\n\nIn this the input is linearly proportional to the error, which means that the error is just scaled using the constant **Kp**.\n\n**Integral(I)**\n\nThe integral of error over time is scaled with a constant **Ki**.\n\n**Derivative(D)**\n\nHere, the derivative of the error is scaled and multiplied by the constant **Kd**.\n\nEach of the above components aims to correct different causes of the error, and together these three combine to give us the best desired output.\n\nLet‚Äôs understand the use of all the above three components using an example of a self-driving car. We have to design the controls of the vehicle. The car is supposed to move on a given marked line. Let's start with our analysis:\n\nThe input given to the car is to turn its steering wheel to left or right by a fixed angle, as shown below.\n\n![](/ERC-website-2021/static/image8.png)\n\nBut there is a problem with this; we are instructing to turn the steering wheel by the same angle even if the car is slightly offset. This will make the vehicle constantly oscillate around the line, and the ride will be jerky, making it uncomfortable for the passengers.\n\n![](/ERC-website-2021/static/image3.png)\n\nSo what can be done to solve this? We need to turn the steering wheel in proportion to the error, i.e., its offset from the line. This is where the P part comes into play. Notice what will happen if we give the input as: _u(t) = Kp e(t)_\n\n![](/ERC-website-2021/static/image2.png)\n\nHere we turn the steering by a smaller angle if the error is small and the problem is solved. But there is a problem with this too! This control works well with low offset, but it may lead to a situation like below when the error is high.\n\n![](/ERC-website-2021/static/image7.png)\n\nSince the initial angle is high, the steering angle is relatively high, but as a result, it leads to the car closing in on the line much quicker, even quicker than what the car can account for by decreasing the angle; hence it will overshoot. And again, the same story will repeat from the other side, leading to oscillations.\n\nSo how do we solve this? Here‚Äôs where the D part comes in handy. The input is modified as:  _u(t) = Kp e(t)  +  Kd e'(t)_\n\nThe added term takes into account the rate of change of error. So if the error is decreasing rapidly, _e'(t)_ will be highly negative. So when the error is enormous, the proportional part will be high, but as the car starts to steer, the derivative term will increase in the negative direction, avoiding the car to turn too quickly. So we will get an ideal situation as below:\n\n![](/ERC-website-2021/static/image4.png)\n\nThis is collectively known as **PD control**.\n\nWait! There is still a problem. Only P and D can lead to an error known as steady-state error. Take the following case: Let's say the car is driving at a small constant error parallel to the marked line (purple).\n\n![](/ERC-website-2021/static/image1.png)\n\nHow will the P and D act in this case? Since the error is small, the proportional part will steer through a slight angle, but as soon as it starts turning, _e'(t)_ will become negative and nullify the P term; hence the car will continue with a constant error (steady-state error).\n\nThe I part helps to account for this error. The input function now becomes:\n\n`u(t) = Kp e(t) + Kd e'(t) + Ki ‚à´e(t).dt`\n\nIntegral term adds the net error till the current time and tries to make it zero.\n\nSo here, the integral part will add up the steady-state error and slowly reduce the error.\n\nAs we can see from the above image, the initial small steady-state error is quickly reduced to zero using the _Integral_ term.\n\nThis completes our analysis of the **PID** control law. Note that the constants Kp, Kd  & Ki are tuned ample times to get the perfect combination of the three, such that none of them overshadows the other terms, and we get our desired output.\n\nSo we come to an end of this short introduction to Control Theory. It is a math-heavy topic, and this was quite a superficial picture. For those interested to learn further and reading more about Control theory, you may go through the Controls Theory Bootcamp conducted by ERC. It involves a mathematical approach which is needed for a deeper understanding of the topic. The link for it is [here](https://github.com/erciitb/tss-controls-theory \"here\").","slug":"controls-theory"},{"frontmatter":{"title":"Sensor Fusion","author":"Govind Saju","hero_image":"/ERC-website-2021/static/fusion_sensors_cover.jpg","date":"2021-11-24T12:30:00.000Z"},"markdownBody":"Sensor Fusion refers to the process of combining measurements from different sources to ensure that resulting information has lesser uncertainty as compared to any of the individual measurements. As an example, we can calculate depth information from 2-D images by combining data from 2 cameras at slightly different locations.\n\nThe different sources for the information we obtain need not be identical. There are three types of fusion methods:\n\n* **Direct Fusion:** Fusion of data from a set of either heterogenous or homogenous set of sensors along with past history of sensor data\n* **Indirect Fusion:** Along with sources in direct fusion, we also use sources like a priori knowledge about the information, and human input.\n* **Combination of both:** We can also obtain information by combining the outputs of the above 2 methods of fusion\n\n# Classification of Sensor Fusion Algorithms\n\nSensor Fusion algorithms can be classified on different parameters:\n\n## On the basis of Abstraction Level (When?)\n\n* **Low Level Fusion:** Fusing the raw data coming in from different sensors\n* **Mid Level Fusion:** Fusing the detections from each sensor\n* **High Level Fusion:** Fusing the trajectories (predictions) of each sensor\n\n![](/ERC-website-2021/static/fusion_sensors_image3.png)\n\n## On the basis of Centralization Level (Where?)\n\n* **Centralized:** A single central unit deals with the fusion\n* **Decentralized:** Each sensor fuses the data and sends it onto the next one\n* **Distributed:** Each sensor fuses data locally and sends it to the next unit\n\n![](/ERC-website-2021/static/fusion_sensors_image2.png)\n\n## On the basis of Composition Level (What?)\n\n* **Competitive Fusion:** When different sensors are meant for the same purpose\n* **Complementary Fusion:** When different sensors are used to look at different scenes to obtain data that couldn‚Äôt have been obtained had the been used individually\n* **Coordinated Fusion:** Using multiple sensors to produce a new scene, but looking at the same object. E.g. 3D reconstruction\n\n![](/ERC-website-2021/static/fusion_sensors_image1.png)\n\nFor more details regarding the types of sensor fusion, check [here](https://www.thinkautonomous.ai/blog/?p=9-types-of-sensor-fusion-algorithms \"https://www.thinkautonomous.ai/blog/?p=9-types-of-sensor-fusion-algorithms\").\n\n**Example Calculation Regarding Sensor Fusion**\n\nFor a basic example showing how two measurements can be combined, check [this](https://en.wikipedia.org/wiki/Sensor_fusion#Example_calculations \"https://en.wikipedia.org/wiki/Sensor_fusion#Example_calculations\") section.\n\n# Algorithms on Sensor Fusion\n\n## Based on Sensor Fusion\n\n* The central limit theorem states that when we take a large number of measurements of a parameter, the distribution of their mean tends to a normal distribution, and the mean of the distribution gets closer to the true mean as number of measurements increase.\n* In order to see its relation to sensor fusion, assume we have two different sensors A and B. The more samples we take of their readings, the more closely the distribution of the sample averages will resemble a bell curve and thus approach the set‚Äôs true average value.  The closer we approach an accurate average value, the less noise will factor into sensor fusion algorithms.\n* For more information regarding the central limit theorem, check [here](https://en.wikipedia.org/wiki/Central_limit_theorem \"https://en.wikipedia.org/wiki/Central_limit_theorem\").\n\n## Based on Kalman Filter\n\n* A Kalman filter is an algorithm that estimates unknown values by taking data inputs from multiple sources, despite possibly having a high amount of signal noise.\n* It has the advantage of predicting unknown values more accurately by combining measurements than what is obtained on using the measurements individually.\n* The Kalman filter is a recursive algorithm that depends only on the previous state of the system and the current observed sensor data to estimate the current state of the system.\n* For more details regarding the Kalman filter, check [here](https://www.kalmanfilter.net/default.aspx \"https://www.kalmanfilter.net/default.aspx\") or [here](https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/ \"https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/\").\n\n## Based on Bayesian Networks\n\n* Bayes Rule in probability is the backbone of state update equations used for sensor fusion. Bayesian Networks based on Bayes rule predicts the likelihood that any given measurement is a contributing factor in determining a given parameter.\n* For a detailed study of Bayesian Networks, check [here](https://en.wikipedia.org/wiki/Bayesian_network \"https://en.wikipedia.org/wiki/Bayesian_network\").\n* Some of the algorithms used for Sensor Fusion based on Bayesian networks are [K2](http://web.cs.wpi.edu/\\~cs539/s05/Projects/k2_algorithm.pdf \"http://web.cs.wpi.edu/~cs539/s05/Projects/k2_algorithm.pdf\"), [hill climbing](https://www.geeksforgeeks.org/introduction-hill-climbing-artificial-intelligence/ \"https://www.geeksforgeeks.org/introduction-hill-climbing-artificial-intelligence/\"), [simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing \"https://en.wikipedia.org/wiki/Simulated_annealing\").\n\n## The Dempster-Shafer Theory\n\n* This theory, called the theory of belief functions or the evidence theory, is a general framework for working with uncertainties and measurements.\n* Dempster‚ÄìShafer theory is based on two ideas: obtaining degrees of belief for one question from subjective probabilities for a related question, and Dempster's rule for combining such degrees of belief when they are based on independent items of evidence.\n* For more details on this theory, check [here](https://en.wikipedia.org/wiki/Dempster%E2%80%93Shafer_theory \"https://en.wikipedia.org/wiki/Dempster%E2%80%93Shafer_theory\") or [here](https://www.geeksforgeeks.org/ml-dempster-shafer-theory/ \"https://www.geeksforgeeks.org/ml-dempster-shafer-theory/\").\n\n## Convolutional Neural Networks\n\n* Convolutional neural network based methods can simultaneously process many channels of sensor data. From this fusion of such data, they produce classification results based on image recognition.\n* For a detailed study of CNNs, check [here](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53 \"https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53\").\n\n# Conclusion\n\nSensor Fusion is a vast field, with a huge number of algorithms to combine sensor data to obtain measurements. The mathematics behind sensor fusion is often complicated and requires a good understanding of concepts of probability. The goal of this article was to give a brief overview of different types of sensor fusion and to give a bird‚Äôs eye view of the various algorithms that can be used for sensor fusion.","slug":"sensor-fusion"}],"title":"ERC: Blog","description":"Electronics and Robotics Club, IIT Bombay's Blog"},"__N_SSG":true}